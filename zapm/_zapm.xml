<?xml version="1.0" encoding="UTF-8"?>
<Export generator="IRIS" version="26">
<Class name="%ZAPM.ext.Production">
<Description>
Utilities for group work with Ensemble or Interoperability products of different Namespaces
do ##class(%ZAPM.ext.Production).SaveAndStop()
do ##class(%ZAPM.ext.Production).StartAll()</Description>
<Abstract>1</Abstract>
<IncludeCode>%ZAPM.ext.Common</IncludeCode>
<TimeCreated>65607,76510.942315</TimeCreated>

<Parameter name="TIMEOUTSTOP">
<Description>
How long to wait for the product to stop before being stopped again by force (seconds)</Description>
<Default>60</Default>
</Parameter>

<Parameter name="SettingsGN">
<Default>^%ZAPM.ext.Productions</Default>
</Parameter>

<Method name="SaveStat">
<Description>
 Check and save settings and status of products in all Namespaces
 d ##class(%ZAPM.ext.Production).SaveStat(1)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>resave=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s listns=..ListNS(.inf,"NotPref,Ens")
	s GN=..#SettingsGN
	i 'resave,$d(@GN) w !,"Settings have already been saved. Rewrite ? [Y/N] <N>" r r q:$zconvert(r,"L")'["y"
	KILL @GN
	MERGE @GN=inf
	w !,"Updated "_GN,!!
	s ns=""
	f { s ns=$o(inf(ns)) q:ns=""
	 zw inf(ns,"Ens")
	}
 quit $$$OK
]]></Implementation>
</Method>

<Method name="ListNS">
<Description>
Get a list of domain namespaces separated by commas
w ##class(apptools.core.sys).ListNS(.info,"NotPre,Ens")
Flag = "Ens" - only where the ensemble is installed
Flag = "NotPre" - exclude prepared</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>info,Flag=""</FormalSpec>
<Implementation><![CDATA[
	s disp=""
	$$$NspGoto(curNs,"%SYS")	
	set tRS = ##class(%ResultSet).%New("Config.Namespaces:List")
	if '$isobject(tRS) q ""
	set tSC = tRS.Execute()
	While tRS.Next() {	
		s name=tRS.GetData(1) KILL ens
		if Flag["NotPre" continue:..IsPreparedNS(name)
		if Flag["Ens",..getEnsProd(name,.ens) k info("Ens") m info(name,"Ens")=ens
		s disp=disp_","_name
		m info(name)=tRS.Data
	}
	d tRS.Close()
	$$$NspReturn(curNs)	
	Q $g(disp)
]]></Implementation>
</Method>

<Method name="getEnsProd">
<Description>
Get a list of products in namespace
w ##class(apptools.core.sys).getEnsProd("ENSDEMO",.info)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name,info</FormalSpec>
<Implementation><![CDATA[
	s sc=$$$OK
	try {
		$$$NspGoto(curNs,name) KILL info
		DO ##CLASS(Ens.Director).GetProductionSummary(.info,name)
	}
	catch e { s sc=$$$ERROR($$$GeneralError,$ze)}
	$$$NspReturn(curNs)
	Q sc
]]></Implementation>
</Method>

<Method name="IsPreparedNS">
<Description>
Check whether the namespace is prepared
w ##class(apptools.core.sys).IsPreparedNS("%SYS")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name</FormalSpec>
<Implementation><![CDATA[	quit $lf($lb("%SYS","%ALL","DOCBOOK","ENSDEMO","ENSEMBLE","SAMPLES","USER"),$zconvert(name,"U"))
]]></Implementation>
</Method>

<Method name="SaveAndStop">
<Description>
 Save settings and status of products in all Namespaces; Stop all productions
 d ##class(%ZAPM.ext.Production).SaveAndStop()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	d ..SaveStat(1)
	d ..StopAll()
]]></Implementation>
</Method>

<Method name="StopAll">
<Description>
Remove autostart from all products; stop all products in Namespaces before restarting the OS
d ##class(%ZAPM.ext.Production).StopAll()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 d ..EnsAction("auto0")
 d ..EnsAction("stop")
 w !!,"ok"
 q
]]></Implementation>
</Method>

<Method name="StartAll">
<Description>
Check and restore autorun products in Namespaces, run all products that were launched
d ##class(%ZAPM.ext.Production).StartAll()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 	d ..EnsAction("auto1")
 	d ..EnsAction("start")
 	w !!,"ok"
 	q
]]></Implementation>
</Method>

<Method name="EnsAction">
<Description>
Change products status in Namespaces
d ##class(%ZAPM.ext.Production).EnsAction("restart")
ex= "auto0" - clean all Namespaces of auto start products
ex= "auto1" - enable auto start products, restore from #SettingsGN(ns)
ex= "stop"  - stop all products
ex= "restart"  - reload all products
ex= "start"  - run the ones that were started, restore from #SettingsGN(ns)
ex= "status" - output statuses
ex= "info" - output of additional information about products and services with parameters d ##class(%ZAPM.ext.Production).EnsAction("info",,.out)
out - result ;d ##class(%ZAPM.ext.Production).EnsAction("status",$Namespace,.out)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ex="",nsOnly="",out</FormalSpec>
<PublicList>tProductionName,inf</PublicList>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	;get all namespace with ensemble
	s listns=..ListNS(.inf,"NotPref,Ens")
	#define NotSaveStat " settings not saved, to do ##class(%ZAPM.ext.Production).SaveStat(1) "
	$$$forAll(ns,inf)
	i nsOnly'="",nsOnly'=ns continue
	$$$NspGoto(curN,ns)
	i '$d(inf(ns,"Ens")) continue
	s GN=..#SettingsGN
	i ex'="info" w !!,"--- ",ns
	if ex="stop" {
		s sc=##class(Ens.Director).StopProduction(..#TIMEOUTSTOP)
		i 'sc {
			s sc2=##class(Ens.Director).StopProduction(..#TIMEOUTSTOP,1) 
			i 'sc2 w $System.Status.DisplayError(sc2)
		}
	}
	elseif ex="restart" {
		s sc=##class(Ens.Director).RestartProduction()
		i 'sc w $System.Status.DisplayError(sc)
	}
	elseif ex="start" {
		i '$d(@GN@(ns,"Ens")) w !,$$$NotSaveStat
		$$$forAll(tProductionName,@GN@(ns,"Ens"))
			continue:$lg(@GN@(ns,"Ens",tProductionName),1)'[$$$EnsProductStatusRun
			w !,ns," ",tProductionName
			Set sc = ##class(Ens.Director).StartProduction(tProductionName) ; Quit:$$$ISERR(tSC)
			i 'sc w $System.Status.DisplayError(sc)
		$$$forEnd	
	}
	if ex="auto0" {
		i '$d(@GN@(ns,"Ens")) w !,$$$NotSaveStat
			$$$NspGoto(curNs,ns)
			Set sc = ##class(Ens.Director).SetAutoStart("")
			i 'sc w $System.Status.DisplayError(sc)
			e  w " clean auto start"
			$$$NspReturn(curNs)
	} elseif ex="auto1" {
		i '$d(@GN@(ns,"Ens")) w !,$$$NotSaveStat
		$$$forAll(tProductionName,@GN@(ns,"Ens"))
			continue:'$lg(@GN@(ns,"Ens",tProductionName),4)
			$$$NspGoto(curNs,ns)
			Set sc = ##class(Ens.Director).SetAutoStart(tProductionName)
			i 'sc w $System.Status.DisplayError(sc)
			e  w " set auto start"
			$$$NspReturn(curNs)
		$$$forEnd		
	} elseif ex="status"||(ex="info") {
		i '$d(@GN@(ns,"Ens")) w !,$$$NotSaveStat
		Set sc = ##class(Ens.Director).GetProductionSummary(.pInfo, ns)	if ex'="info" w ! zw pInfo
		Set sc = ##class(Ens.Director).GetProductionSettings("",.tSettings)	if ex'="info" w ! zw tSettings
		$$$forAll(tProductionName,@GN@(ns,"Ens"))
			;continue:'$lg(@GN@(ns,"Ens",tProductionName),4)
			$$$NspGoto(curNs,ns)
			if ex'="info" w !,"Name production :"_tProductionName
			Set sc = ##class(Ens.Director).GetProductionStatus(tProductionName,.Stat)
			s stat=$s(Stat=1:"Running",Stat=2:"Stopped",Stat=3:"Suspended",Stat=4:"Troubled",1:"?")
			if ex'="info" w " Status :"_stat
			i 'sc w $System.Status.DisplayError(sc)
			s out(ns,tProductionName)=stat
			;if ex="info" k ou d ..ExtInfo(tProductionName,.ou) m out(ns,tProductionName)=ou
			$$$NspReturn(curNs)
		$$$forEnd		
	}
	$$$forEnd
	if $g(curN)'="" $$$NspReturn(curN)
 	quit $$$OK
]]></Implementation>
</Method>

<Method name="init">
<Description>
do ##class(%ZAPM.ext.Production).init()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	new $namespace
	set $namespace="%sys"
	;init
	write !,"To work in the shell, enter 'zapm' in the terminal, and then 'StopProd' or 'StartProd' "
	quit $$$OK
]]></Implementation>
</Method>

<Method name="exportXMLprod">
<Description>
do ##class(%ZAPM.ext.Production).exportXMLprod("d:\_proj\_zapp\zpm-addition+\zapm-addcmd\addcmd\zapm\_zapmprod.xml")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>dir=""</FormalSpec>
<Implementation><![CDATA[
 	s list("%ZAPM.ext.Common.INC")=""
	s list("%ZAPM.ext.Production.CLS")=""
	d $SYSTEM.OBJ.Export(.list, dir)
]]></Implementation>
</Method>
</Class>


<Class name="%ZAPM.ext.commands">
<IncludeCode>%ZAPM.ext.Common</IncludeCode>
<Super>%Persistent</Super>
<TimeCreated>65607,76509.946449</TimeCreated>

<Property name="Command">
<Description>
Command</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="CommandName">
<Description>
Commands name</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Partition">
<Description>
Partition </Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Description">
<Description>
Description</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Prompt">
<Description>
Prompt (yes, no, never run - show only)</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="Namespace">
<Description>
Namespace</Description>
<Type>%String</Type>
<Parameter name="MAXLEN"/>
</Property>

<Property name="TimeStamp">
<Description>
Date and time</Description>
<Type>%TimeStamp</Type>
<InitialExpression>$zdt($h, 3, 1)</InitialExpression>
</Property>

<Index name="idxCommand">
<Properties>Command</Properties>
</Index>

<Index name="idxCommandName">
<Properties>CommandName</Properties>
</Index>

<Method name="GetList">
<Description>
Get List commands
do ##class(%ZAPM.ext.commands).GetList(.list)
do $CLASSMETHOD("%ZAPM.ext.commands", "%KillExtent")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&list,Command:%String="",CommandName="",Partition="",Prompt="",Description="",Namespace=""]]></FormalSpec>
<Implementation><![CDATA[
	Set tQuery = "select * from %ZAPM_ext.commands where (1=1) "
	Set tRes = ##class(%SQL.Statement).%ExecDirect(,tQuery)
	
	If (tRes.%SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
	}
	While tRes.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		set part=tRes.%Get("Partition")
		if part="" set part="Other"
		Set list(part,$i(list))=$lb(tRes.%Get("Command"),tRes.%Get("Prompt"),tRes.%Get("CommandName"),tRes.%Get("Description"),tRes.%Get("Partition"))
	}
]]></Implementation>
</Method>

<Method name="GetCmd">
<Description>
Get command
do ##class(%ZAPM.ext.commands).GetCmd("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","help",.cmd,.id) </Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Command="",CommandName="",cmd,id</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tQuery = "select * from %ZAPM_ext.commands where (1=1) "
	if CommandName="" set tQuery=tQuery_" and CommandName is null "
	else  set tQuery=tQuery_" and CommandName='"_CommandName_"'"
	if Command'="" set tQuery=tQuery_" and Command='"_Command_"'"
	Set tRes = ##class(%SQL.Statement).%ExecDirect(,tQuery)
	set cmd="",id=""
	If (tRes.%SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
	}
	While tRes.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		Set cmd=$lb(tRes.%Get("Command"),tRes.%Get("Prompt"),tRes.%Get("CommandName"),tRes.%Get("Description"),tRes.%Get("Partition"))
		set id=tRes.%Get("ID")
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="AddUpdate">
<Description>
Add new command
write $System.Status.GetErrorText(##class(%ZAPM.ext.commands).AddUpdate("new $namespace zn ""zpmshow"" do ^zpmshow","zshow","zpm","n","Show a zpm modules with extention description"))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Command:%String="",CommandName="",Partition="",moderun="",Description="",Namespace=""</FormalSpec>
<Implementation><![CDATA[
	#dim obj As %ZAPM.ext.commands = ""
	Set tQuery = "select * %ZAPM_ext.commands where (1=1) "
	if Command="" $$$ThrowOnError($$$ERROR($$$GeneralError,"Command is empty"))
	do ..GetCmd(Command,CommandName,.cmd,.id)
	;w !,Command,!,CommandName,!,"id = "_$g(id)
	if cmd'="" set obj=..%OpenId(id)
	if '$iso(obj) Set obj = ..%New()
	set obj.Command=Command
	set obj.CommandName=CommandName
	set obj.Partition=Partition
	set obj.Description=Description
	set obj.Prompt=$zconvert($e(moderun,1),"L")
	set obj.Namespace=Namespace
	quit obj.%Save()
]]></Implementation>
</Method>

<Storage name="Default">
<Type>%Storage.Persistent</Type>
<DataLocation>^%ZAPM.ext.commandsD</DataLocation>
<DefaultData>commandsDefaultData</DefaultData>
<IdLocation>^%ZAPM.ext.commandsD</IdLocation>
<IndexLocation>^%ZAPM.ext.commandsI</IndexLocation>
<StreamLocation>^%ZAPM.ext.commandsS</StreamLocation>
<Data name="commandsDefaultData">
<Value name="1">
<Value>%%CLASSNAME</Value>
</Value>
<Value name="2">
<Value>Command</Value>
</Value>
<Value name="3">
<Value>CommandName</Value>
</Value>
<Value name="4">
<Value>Partition</Value>
</Value>
<Value name="5">
<Value>Namespace</Value>
</Value>
<Value name="6">
<Value>TimeStamp</Value>
</Value>
<Value name="7">
<Value>Prompt</Value>
</Value>
<Value name="8">
<Value>Description</Value>
</Value>
</Data>
</Storage>
</Class>


<Class name="%ZAPM.ext.database">
<Description>
Utility for creating and deleting databases with one command 
Create DataBase and Namespace with CSP, REST application 
Forked from https://openexchange.intersystems.com/package/isc-generate-db

Added resource and role creation for the database. (Many modules ZPM require MatchRoles=":{$dbrole}")
Added deletion of DataBases, role resources and Namespace.
Adding rest application is optional.

example:
write $System.Status.GetErrorText(##class(%ZAPM.ext.database).CreateDBNS("TESTDB2"))
write $System.Status.GetErrorText(##class(%ZAPM.ext.database).DeleteDBNS("TESTDB2"))
create db and namespace without resource and role
write $System.Status.GetErrorText(##class(%ZPM.PackageManager.Developer.UnitTest.Utils).CreateNamespace("testdb14"))
write $System.Status.GetErrorText(##class(%ZPM.PackageManager.Developer.UnitTest.Utils).DeleteNamespace("testdb14"))</Description>
<Abstract>1</Abstract>
<TimeCreated>65687,72123.672838</TimeCreated>

<Parameter name="LIBRARY">
<Expression>$Select($Select($ZVersion["IRIS":1,1:0):"IRISLIB",1:"CACHELIB")</Expression>
</Parameter>

<Parameter name="SYSGLOBALS">
<Expression>$Select($Select($ZVersion["IRIS":1,1:0):"IRISSYS",1:"CACHESYS")</Expression>
</Parameter>

<Parameter name="TEMPGLOBALS">
<Expression>$Select($Select($ZVersion["IRIS":1,1:0):"IRISTEMP",1:"CACHETEMP")</Expression>
</Parameter>

<Parameter name="DATABASENAME">
<Expression>$Select($Select($ZVersion["IRIS":1,1:0):"IRIS.DAT",1:"CACHE.DAT")</Expression>
</Parameter>

<Method name="Init">
<ClassMethod>1</ClassMethod>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	write !,"Creating and deleting db, namespace, resource and role with one command"
	write !,"example:"
	write !,"write $System.Status.GetErrorText(##class(appmsw.util.database).CreateDBNS(""TESTDB2""))"
	write !,"write $System.Status.GetErrorText(##class(appmsw.util.database).DeleteDBNS(""TESTDB2""))",!
	quit $$$OK
]]></Implementation>
</Method>

<Method name="CreateDBNS">
<Description>
write ##class(%ZAPM.ext.database).CreateDBNS("NEWNS")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pCodeData:%Boolean=0,pPathDataset:%String="",pInterOperability:%Boolean=1,pREST:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set pNamespace=$ZCONVERT(pNamespace,"L")
	quit ..Install(pNamespace, pCodeData, pPathDataset, pInterOperability, pREST)
]]></Implementation>
</Method>

<Method name="Install">
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pCodeData:%Boolean=1,pPathDataset:%String="",pInterOperability:%Boolean=0,pREST:%String=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    Try {
        Set sc = $$$ADDSC(sc,..CreateDatabase(pNamespace, pCodeData, pPathDataset)) quit:$$$ISERR(sc)
        Set sc = $$$ADDSC(sc,..CreateNamespace(pNamespace, pCodeData, pInterOperability, pREST)) quit:$$$ISERR(sc)
    }
    Catch (err) {
        Set sc = $$$ADDSC(sc,err.AsStatus())
    }
    Return sc
]]></Implementation>
</Method>

<Method name="CreateDatabase">
<Description>
Create new database directory</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pCodeData:%Boolean,pPathDataset:%String=""</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set CurrNS=$Namespace
    New $Namespace
    Set $Namespace = "%SYS"
    Set sc = $$$OK
    Try {
        Set dbList = $Listbuild("")
        Set:(pCodeData = $$$YES) dbList= $Listbuild("-CODE","-DATA") 

        For i = 1:1:$Listlength(dbList) {
            Set dbSuffix = $Listget(dbList,i)
            If (pPathDataset '= "") {
                Set directory = pPathDataset_$Case($$$isWINDOWS,1:"\",:"/")_pNamespace_dbSuffix
            }
            Else {
                Set directory = ..GetDatabaseDirectory(pNamespace_dbSuffix)
            }

            #; create a new directory if does not exist
            If '..CheckDatabaseDirExists(directory) {
                Set directory = $ZStrip(directory,"<>W")
                Set sc = $$$ADDSC(sc,##class(%File).CreateDirectoryChain(directory))
                If $$$ISERR(sc) {
                    Set msg = directory_": Could not create this directory. Please check the directory and try again."
                    Set sc = $$$ADDSC(sc,$$$ERROR($$$GeneralError,msg))				
                }
            }
            Else {
                #; abort if database is already created
                If ..CheckDatabaseExists(directory) {
                    Set msg = directory_": Database already existent in this directory. Please check the directory and try again."
                    Set sc = $$$ADDSC(sc,$$$ERROR($$$GeneralError,msg))
                }
            }
            Quit:$$$ISERR(sc)

            #; create new Resource
            Set dbName = pNamespace_dbSuffix
            set $Namespace=CurrNS
            Set sc = $$$ADDSC(sc,..CreateRole($ZCONVERT(dbName,"U")))
            Quit:$$$ISERR(sc)
            Set $Namespace = "%SYS"
            
            #; create new database
            Write "Creating Database "_dbName_"... "
            Set size = 1
            Set blockSize = 8192
            Set properties("Directory") = directory
            Set journalState = 1
            Set sc = $$$ADDSC(sc,##class(SYS.Database).CreateDatabase(directory,size,blockSize,0,"%DB_"_dbName,journalState,"",""))
            Quit:$$$ISERR(sc)

            #; Handle if we have dismounted then deleted the database at the O/S level,
            #; but the CPF entry still exists with the same directory, then recreate the DB only
            If ##class(Config.Databases).Exists(dbName,.obj) {
                If obj.Directory '= ##class(%File).ComputeFullDBDir(directory) {
                    Set sc = $$$ADDSC(sc,##Class(Config.Databases).Create(dbName,.properties))
                    Quit:$$$ISERR(sc)
                }
            }
            Else {
                Set sc = $$$ADDSC(sc,##Class(Config.Databases).Create(dbName,.properties))
                Quit:$$$ISERR(sc)
            }
            Write "done!",!
        }
    }
    Catch (err) {
        Set sc = $$$ADDSC(sc,err.AsStatus())
    }
    Return sc
]]></Implementation>
</Method>

<Method name="CreateRole">
<Description>
Create new Role
w $system.Status.GetErrorText(##class(%ZAPM.ext.database).CreateRole("SWAGGERUI-CODE"))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>dbName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   ;create new role
   New $Namespace
   Set $Namespace = "%SYS"
   Set sc = $$$OK
   s nameR="%DB_"_dbName,desc="Role for "_nameR 
	s pResources=nameR_":RW" 
	if '##class(Security.Resources).Exists(nameR) {
		Set sc = $$$ADDSC(sc,##class(Security.Resources).Create(nameR,"Resources for "_nameR,"RW"))
		Quit:$$$ISERR(sc) sc
	}
	s pRolesGranted=""
	if '##class(Security.Roles).Exists(nameR) {
		Set sc = $$$ADDSC(sc,##class(Security.Roles).Create(nameR,desc,pResources,pRolesGranted))
		Quit:$$$ISERR(sc) sc
		w !,"Create new role "_nameR
	}
	Return sc
]]></Implementation>
</Method>

<Method name="CreateResource">
<Description>
Create new Resource
w $system.Status.GetErrorText(##class(%ZAPM.ext.database).CreateResource("DSW-DATA"))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>dbName:%String,Permiss:%String="RW"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
   ;create new resource
   New $Namespace
   Set $Namespace = "%SYS"
    Set sc = $$$OK
   s nameR="%DB_"_dbName,desc="Resource for "_nameR 
	if '##class(Security.Resources).Exists(nameR) {
		Set sc = $$$ADDSC(sc,##class(Security.Resources).Create(nameR,desc,Permiss))
		Quit:$$$ISERR(sc) sc
		w !,"Create new Resource "_nameR
	}
	Return sc
]]></Implementation>
</Method>

<Method name="DeleteResource">
<Description>
Delete Resource
w $system.Status.GetErrorText(##class(%ZAPM.ext.database).DeleteResource("DSWDATA"))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>dbName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 New $Namespace
 Set $Namespace = "%SYS"
 Set sc = $$$OK
   s nameR="%DB_"_dbName
	if ##class(Security.Resources).Exists(nameR) {
		Set sc = $$$ADDSC(sc,##class(Security.Resources).Delete(nameR))
		Quit:$$$ISERR(sc) sc
		w !,"Delete Resource "_nameR
	}
	Return sc
]]></Implementation>
</Method>

<Method name="DeleteRole">
<Description>
Delete Role
w $system.Status.GetErrorText(##class(%ZAPM.ext.database).DeleteRole("DSWDATA"))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>dbName:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 New $Namespace
 Set $Namespace = "%SYS"
 Set sc = $$$OK
   s nameR="%DB_"_dbName
	if ##class(Security.Roles).Exists(nameR) {
		Set sc = $$$ADDSC(sc,##class(Security.Roles).Delete(nameR))
		Quit:$$$ISERR(sc) sc
		w !,"Delete role "_nameR
	}
	Return sc
]]></Implementation>
</Method>

<Method name="CreateNamespace">
<Description>
Create new namespace</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,pCodeData:%Boolean,pInterOperability:%Boolean,pREST:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[

    New $Namespace
    Set $Namespace = "%SYS"

    If (pCodeData = $$$YES) {
        Set strGlobals = pNamespace_"-DATA"
        Set strRoutine = pNamespace_"-CODE"
    }
    Else {
        Set (strGlobals, strRoutine) = pNamespace
    }

    Set sc = $$$OK
    Try {

        Write "Creating Namespace "_pNamespace_"... "

        Set nsProperties("Globals") = strGlobals
        Set nsProperties("Library") = ..#LIBRARY
        Set nsProperties("Routines") = strRoutine
        Set nsProperties("SysGlobals") = ..#SYSGLOBALS
        Set nsProperties("SysRoutines") = ..#SYSGLOBALS
        Set nsProperties("TempGlobals") = ..#TEMPGLOBALS
        Set sc = $$$ADDSC(sc,##Class(Config.Namespaces).Create(pNamespace,.nsProperties))

        Write "done!",!

        #; enable Interoperability
        If (pInterOperability = $$$YES) {
            Write "Creating Interoperability mappings ... "
            #; create InterOperability mappings
            Set:'$Data(^%SYS("Ensemble","InstalledNamespace",pNamespace)) ^%SYS("Ensemble","InstalledNamespace",pNamespace)=""
            Set sc = $$$ADDSC(sc,##class(%EnsembleMgr).createMappings(pNamespace))
            Write "done!",!

            Write "Adding Interoperability SQL privileges ... "
            #; add InterOperability SQL privileges
            Set sc = $$$ADDSC(sc,##class(%EnsembleMgr).addEnsembleSQLPrivileges(pNamespace))	
            Write "done!",!
        }
        Set sc = $$$ADDSC(sc,..CreateCSPApplication(pNamespace))
        If (pREST '= "") {
            Set sc = $$$ADDSC(sc,..createRESTApp(pNamespace,pREST))
        }
    }
    Catch (err) {
        Set sc = $$$ADDSC(sc,err.AsStatus())
    }
    Return sc
]]></Implementation>
</Method>

<Method name="CreateCSPApplication">
<Description>
Create CSP application</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    Set sc = $$$OK
    New $Namespace
    Set $Namespace="%SYS"
    Try {
        Write "Creating CSP Application ... "
        Set lower = $ZConvert(pNamespace,"L")
        Set del = $Case($$$isWINDOWS,1:"\",:"/")
        Set cspName = "/csp/"_lower

        Set properties("Name") = cspName
        Set properties("CookiePath") = "/csp/"_lower
        Set properties("AutheEnabled") = $$$AutheUnauthenticated
        Set properties("NameSpace") = pNamespace
        Set properties("Path") = ##class(%File).GetDirectory($zu(86))_"csp"_del_lower
        Set properties("GroupById") = $$$IscMgtPortalId
        Set properties("AutoCompile") = 1

        // If the application exists, quit
        If '##class(Security.Applications).Exists(cspName,.existingApp,.sc2) {
            // Create the csp application properties	
            Set sc = $$$ADDSC(sc,##class(Security.Applications).Create(cspName,.properties))
        }
        Else {
            Set sc = $$$ADDSC(sc,sc2)
        }
        Write "done!",!
    }
    Catch (err) {
        Set sc = $$$ADDSC(sc,err.AsStatus())
    }
    Return sc
]]></Implementation>
</Method>

<Method name="createRESTApp">
<Description>
Create REST Application</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,DispatchClass="REST.Dispatch"</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    #dim sc As %Status = $$$OK

    New $Namespace
    Set $Namespace = "%SYS"

    Write "Creating CSP Application ... "

    Set lower = $ZConvert(pNamespace,"L")
    Set restName = "/rest/"_lower

    If '##class(Security.Applications).Exists(restName) {
        Set props("AutheEnabled") = $$$AutheUnauthenticated
        Set props("NameSpace") = pNamespace
        Set props("IsNameSpaceDefault") = $$$NO
        Set props("DispatchClass") = DispatchClass
        Set props("MatchRoles")=":%All"
        Set sc = ##class(Security.Applications).Create(restName, .props)
        Write "done!",!


        Write "Creating "_DispatchClass_".cls ... "
        Do ..CreateDispatchClass(pNamespace,DispatchClass)
        Write "done!",!
    }

    Quit sc
]]></Implementation>
</Method>

<Method name="CreateDispatchClass">
<Description>
Create a dummy REST service to populate messages</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace:%String,classname="REST.Dispatch"</FormalSpec>
<Private>1</Private>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
    New $Namespace
    Set $Namespace = pNamespace
    Set sc = $$$OK
    Try {
        ;Set classname = "REST.Dispatch"
        Set class = ##class(%Dictionary.ClassDefinition).%New(classname)
        Set class.GeneratedBy = $ClassName()
        Set class.Super = "%CSP.REST"

        Set xdata = ##class(%Dictionary.XDataDefinition).%New()
        Set xdata.Name = "UrlMap"
        Set xdata.XMLNamespace = "http://www.intersystems.com/urlmap"
        Do xdata.Data.WriteLine("<Routes>")
        Do xdata.Data.WriteLine("<Route Url=""/"" Method=""GET"" Call=""Test"" Cors=""true""/>")
        Do xdata.Data.WriteLine("</Routes>")
        Do class.XDatas.Insert(xdata)
        Set sc = $$$ADDSC(sc,class.%Save())

        Set method = ##class(%Dictionary.MethodDefinition).%New(classname)
        Set method.Name = "Test"
        Set method.ClassMethod = 1
        Set method.ReturnType = "%Status"
        Set stream = ##class(%Stream.TmpCharacter).%New()
        Do stream.WriteLine("	Set %response.ContentType = ""application/json"" ")
        Do stream.WriteLine("	Set retObj = {}")
        Do stream.WriteLine("	Set retMessage = ""Hello World!"" ")
        Do stream.WriteLine("	Set retObj.Message = retMessage")
        Do stream.WriteLine("	Write retObj.%ToJSON()")
        Do stream.WriteLine("	Quit $$$OK")
        Set method.Implementation = stream
        Set sc = $$$ADDSC(sc,method.%Save())

        Set sc = $$$ADDSC(sc,$System.OBJ.Compile(classname,"fck-dv"))
    }
    Catch (err) {
        Set sc = $$$ADDSC(sc,err.AsStatus())
    }
    Return sc
]]></Implementation>
</Method>

<Method name="GetDatabaseDirectory">
<Description>
Get database directory</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>pNamespace:%String</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[##class(%File).SubDirectoryName($System.Util.ManagerDirectory(),pNamespace)
]]></Implementation>
</Method>

<Method name="CheckDatabaseDirExists">
<Description>
Checks if database directory exist</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%File).DirectoryExists(directory)
]]></Implementation>
</Method>

<Method name="CheckDatabaseExists">
<Description>
Checks if database directory exist</Description>
<ClassMethod>1</ClassMethod>
<CodeMode>expression</CodeMode>
<FormalSpec>directory:%String</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[##class(%File).Exists(directory_$Case($$$isWINDOWS,1:"\",:"/")_..#DATABASENAME)
]]></Implementation>
</Method>

<Method name="DeleteDBNS">
<Description>
w $system.Status.GetErrorText(##class(%ZAPM.ext.database).DeleteDBNS("SWAGGERUI", 0))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pNamespace</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	write !,"Delete "_pNamespace
	if $namespace=$ZCONVERT(pNamespace,"U") set $namespace="%SYS"
	Set sc = ##class(%ZPM.PackageManager.Developer.UnitTest.Utils).DeleteNamespace($ZCONVERT(pNamespace,"L"))
	Quit:$$$ISERR(sc) sc
	Set sc = ..DeleteResource($ZCONVERT(pNamespace,"U"))
	;Quit:$$$ISERR(sc) sc
	Set sc = ..DeleteRole($ZCONVERT(pNamespace,"U"))
	;Quit:$$$ISERR(sc) sc
	q sc
]]></Implementation>
</Method>

<Method name="DismountListDB">
<Description>
zn "app" w $System.Status.GetErrorText(##class(%ZAPM.ext.database).DismountListDB("DOJO"))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Database</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	s st=..DismountDB(Database)
	if st {
		s st1=..DismountDB(Database_"ENSTEMP")
		if 'st1 q st1
		s st2=..DismountDB(Database_"SECONDARY")
		if st2 q st2
	} else { q st }
	q $$$OK
]]></Implementation>
</Method>

<Method name="DismountDB">
<Description>
write $System.Status.GetErrorText(##class(%ZAPM.ext.database).DismountDB("PROD"))</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>Database</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	new $namespace
	zn "%sys"
	s st=$$$OK
	If ##Class(Config.Databases).Get(Database,.Properties) {
		Set Directory = $G(Properties("Directory"))
  		Set st = ##class(SYS.Database).DismountDatabase(Directory)
	}
	q st
]]></Implementation>
</Method>
</Class>


<Class name="%ZAPM.ext.zapp">
<Description>
apptools favourite commands in %ZLANGC00.mac
ZAPP(pArgs...) Do ##class(%ZAPM.ext.zapp).prompt(pArgs...) 
try { do ##class(%ZAPM.ext.zapp).UpdateLanguageExtensions() } catch ex {}</Description>
<Abstract>1</Abstract>
<IncludeCode>%ZAPM.ext.Common</IncludeCode>
<TimeCreated>65692,84099.653344</TimeCreated>

<Parameter name="GN">
<Description>
Storage of work history</Description>
<Default>^%ZAPM.hist</Default>
</Parameter>

<Method name="init">
<Description>
do ##class(%ZAPM.ext.zapp).init()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>NoExt=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	new $namespace
	set $namespace="%sys"
	do ..favourite(.list)
	;merge list=@..#GN@("cmd")
	set i=""
	for {
		set i=$Order(list(i)) q:i=""
		set ii="" 
		for { 
			set ii=$Order(list(i,ii),1,val) q:ii=""
			do ##class(%ZAPM.ext.commands).AddUpdate($lg(val,1),$lg(val,3),i,$lg(val,2),$lg(val,4))
		}
	}
	if 'NoExt {
		do ##class(%ZAPM.ext.zapp).UpdateLanguageExtensions()
		do ##class(%ZPM.PackageManager).UpdateLanguageExtensions()
	}
	do ##class(%ZAPM.ext.zpm).SetColorScheme()
	write !,"To work in the shell, enter 'zapm' in the terminal, and then 'cmd' or '?' "
	quit $$$OK
]]></Implementation>
</Method>

<Method name="favourite">
<Description>
do ##class(%ZAPM.ext.zapp).favourite(.list)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&list]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	;sys		           execute code     prompt:yes,no,never=""  name-cmd   description
	set list("sys",$i(list))=$lb("do 1^%SS","i",                    "sys",     "system status")
	set list("sys",$i(list))=$lb("new $namespace zn ""%SYS"" do ^JOBEXAM","a","","job examing")
	set list("sys",$i(list))=$lb("new $namespace zn ""%SYS"" do display^GLOBUFF(25)","i","globuff","show global buffer")
	set list("sys",$i(list))=$lb("new $namespace zn ""%SYS"" do ^LOCKTAB","i","","show lock table")
	set list("sys",$i(list))=$lb("new $namespace zn ""%SYS"" do ^SECURITY","i","","security utility")
	set list("sys",$i(list))=$lb("new $namespace zn ""%SYS"" write ##class(Security.System).ExportAll(""/backup/iris/SecureItem-"_$zu(110)_"-"_$p($zu(86),"*",2)_".xml"", .NumExported)","","")
	set list("sys",$i(list))=$lb("zn ""%SYS"" ","i","zn1","Go to namespace %SYS")
	set list("sys",$i(list))=$lb("w !,""Host "",$zu(110),!,##class(apptools.core.net).GetURI()_""/csp/sys/%25CSP.Portal.Home.zen"",!,""w ##class(apptools.core.net).GetIP()"",!,##class(apptools.core.net).GetIP(),! do ##class(apptools.core.net).GetIPext(,.IPexternal) zw IPexternal ","i","myip","Show my IP")
	
	;sql
	set list("sql",$i(list))=$lb("do $system.SQL.Shell()","i","sql","Shell SQL")
	
	;zmp
	set list("zpm",$i(list))=$lb("zpm ""zn *"" ","i","zna","navigate to namespases")
	set list("zpm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).SetColorScheme()","i","setcolor","set default color scheme")
	set list("zpm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).CreateDBNSAndLoad(""zppretty"")","a","","create new db,namespace and install module")
	set list("zpm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","load","Extension Load module from repo")
	set list("zpm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","help","Extension help command")
	set list("zpm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","ver","Extension show version")
	set list("zpm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","find","Show modules")
	set list("zpm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","repo","Show repository")
	set list("zpm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","upg","Upgrade modules in namespace")
	set list("zpm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","info","Show more complete information about modules")
	;zapm
	set list("zapm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","newdb","create new db,namespace and install module")
	set list("zapm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","dbcreate","create new database and namespace and role")
	set list("zapm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","a","dbdelete","delete database, namespace and role")
	set list("zapm",$i(list))=$lb("write ##class(%ZAPM.ext.zpm).LoadFromRepo(""https://github.com/Vassil2010/iris-sms"")","","","Example Load module from repo")
	set list("zapm",$i(list))=$lb("do ##class(%ZAPM.ext.zapp).addcmd(""new $namespace zn """"zpmshow"""" do ^zpmshow"",""zpm"",""i"",""zshow"",""Show a zpm modules with extention description"")","","","Example added command")
	set list("zapm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","edn","Navigator for namespace and zpm modules")
	set list("zapm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","edg","Globals edotor")
	set list("zapm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","edr","Routine editor")
	set list("zapm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","edf","Navigator for file system")
	set list("zapm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","edt","Navigator for tables")
	set list("zapm",$i(list))=$lb("do ##class(%ZAPM.ext.zpm).extcmd(%cmd)","i","eds","Navigator for sql-queries")
	q $$$OK
]]></Implementation>
</Method>

<Method name="TerminalPrompt">
<ClassMethod>1</ClassMethod>
<FormalSpec>comm=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	set del=$$$escRed(">")
	set tp=##class(%SYSTEM.Process).TerminalPrompt()
	set prompt="zapm:"
	for i=1:1:$l(tp,",") {
		if $p(tp,",",i)=1 {	set prompt=prompt_$p($system,":")_del continue}
		elseif $p(tp,",",i)=2 {	set prompt=prompt_$namespace_del continue}
		elseif $p(tp,",",i)=3 {	set prompt=prompt_$p($system,":",2)_del continue}
		elseif $p(tp,",",i)=4 {	set prompt=prompt_$zt(+$p($h,",",2),1)_del continue}
		elseif $p(tp,",",i)=5 {	set prompt=prompt_$job_del continue}
		elseif $p(tp,",",i)=6 {	set prompt=prompt_$username_del continue}
		;i think for zapm shell 7 and 8 do not need to be implemented
	}
	quit prompt
]]></Implementation>
</Method>

<Method name="prompt">
<Description>
do ##class(%ZAPM.ext.zapp).prompt("globuff")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>comm=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set comm=$ZStrip(comm,"<>WC")
	for {
		if comm="" {
			write !,..TerminalPrompt() 
			read cmd
			set cmd=$ZStrip(cmd,"<>WC")
		}
		else {
			set cmd=comm
		}
		if cmd="" {
			continue
		}
		elseif $lf($lb("q","Q",".","^","h","H",,"zpm","zapp"),cmd) {
			Quit
		}
		elseif cmd="zpm" {
			;quit ##class(%ZPM.PackageManager).Shell()
			;continue
		}
		elseif $$iszapmcmd($p(cmd," "),.command) { 
			;extention command
			set %cmd=cmd
			set yes=$lg(command,2)
			if $e(yes)="a" {
				write !!,"  ",$lg(command,1)_" ; "_$lg(command,4)
				write !,"     Are you sure ? [Y] " 
				read sure 
				continue:$e($zconvert(sure,"L"))'="y"
				set yes="i"
			}
			if yes="i" {
				write !
				xecute $lg(command,1)
				do addhist(command,$lg(command,3),$lg(command,4))
			}
			quit:cmd=comm
			continue
		}
		elseif $$iszpmcmd($p(cmd," ")) { 
			;zpm command
			write !
			d ##class(%ZPM.PackageManager).Shell(cmd)
			do addhist(cmd)
			quit:cmd=comm
			continue
		}
		elseif $e(cmd,1,2)="??"||($e(cmd,1,4)="hist") {
			write !
			do ..history($p(cmd,$select(cmd["??":"??",1:"hist"),2,*)) 
			quit:cmd=comm
			continue
		}
		elseif $e(cmd,1)="?"||($e(cmd,1,3)="cmd") {
			write !
			do ..help($p(cmd,$select(cmd["?":"?",1:"cmd"),2,*)) 
			quit:cmd=comm
			continue
		}		
		elseif (cmd'=(+cmd)) {
			set %cmd=cmd
			try {
				write !
				xecute cmd
				do addhist(cmd)
			} catch ex {
   				write !,"Error "_$ze
   				do ..write("","? or ?text",$lb("Show help"),1)
			}
			quit:cmd=comm
			continue
		}
		elseif $d(%zapm(cmd),command) {
			set yes=$lg(command,2)
			if $e(yes)="a" {
				write !!,"  ",$lg(command,1)_" ; "_$lg(command,4)
				write !,"     Are you sure ? [Y] " 
				 read sure 
				 continue:$e($zconvert(sure,"L"))'="y"
				 set yes="i"
			}
			if yes="i" {
				write !,"Executing "_$lg(command,1),!
				xecute $lg(command,1) 
				do addhist(command,$lg(command,3),$lg(command,4))
				quit:cmd=comm
				continue
			}
			else {
				write !,$lg(command,1),!
				write !,"Show only"
			}
		}
		elseif '$data(%zapm(cmd)) {
				quit:cmd=comm
				continue			
		}
		else { 
			do ..help()
		}
	}
	if cmd="zpm" write ! quit ##class(%ZPM.PackageManager).Shell()
	quit $$$OK
addhist(cmd,namecmd="",desc="") ;add to history
	quit:cmd=+cmd
	quit:cmd=""
	set gn=..#GN
	if '$lv(cmd) s cmd=$lb(cmd,"a",namecmd,desc)
	set @gn@("cmd",cmd)=$GET(@gn@("cmd",cmd))+1
	set @gn@("cmd",cmd,"date")=$h
	quit 1
iszpmcmd(cmd) ;If is a zpm command
	if $lf(##class(%ZAPM.ext.zpm).cmdzpm(),cmd) q $$$OK
	quit 0
iszapmcmd(cmd,command) ;
	do ##class(%ZAPM.ext.commands).GetCmd("",cmd,.comman)
	if comman'="" set command=comman quit 1
	quit 0
]]></Implementation>
</Method>

<Method name="history">
<Description>
hist 
do ##class(%ZAPM.ext.zapp).history("dark")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>mask=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set gn=..#GN
	set mask=$ZStrip(mask,"<>WC")
	if $e(mask,1,4)="-add" { //flag added Number_hist <name_cmd> description
		set num=$p($p(mask,"-add ",2,*)," ")
		if '$D(%zapm(num),cmd) write !,"number invalid" q $$$OK
		set name=$p($p(mask,"-add ",2,*)," ",2)
		set type=$p($p(mask,"-add ",2,*)," ",3)
		set desc=$p($p(mask,"-add ",2,*)," ",4,*)
		if name="" set @..#GN@("cmd",cmd,"nonrem")=$h write !,"added in list non-removable" q $$$OK
		do ##class(%ZAPM.ext.commands).GetCmd("",name,.comman)
		if comman'="" write !,"command name '"_name_"' already exist" q $$$OK
		if '$lf($lb("i","a","n"),type) write !,"command type '"_type_"' invalid" q $$$OK
		do ##class(%ZAPM.ext.zapp).addcmd($lg(cmd,1),"hist",type,name,desc) 
		write !,"added in list of commands" q $$$OK
	}
	if $e(mask,1,4)="-del" { //flag added Number_hist <name_cmd> description
		set days=$p($p(mask,"-del ",2,*)," ",1)
		if days'="" {
			set hor=$h-days
				,count=0
			do ..CreateHistArray(.list)
			set h="" for { set h=$o(list(h),1) q:h=""
				if h<hor {
					set cmd="" for { set cmd=$o(list(h,cmd)) q:cmd=""
						if '$D(@gn@("cmd",cmd,"nonrem")) KILL @gn@("cmd",cmd) set count=count+1
					}
				}
			}
			w !,"killed "_count
		}
		quit $$$OK
	}
	kill %zapm

	set cmd=""
		,num=0
	
	set order=$select($e(mask,1)="+":-1,1:1)
	if $e(mask,1)="-"||($e(mask,1)="+") set mask=$e(mask,2,*)
	do ..CreateHistArray(.list)
	set h="" for { set h=$o(list(h),order) q:h=""
		set cmd=""	for { set cmd=$Order(list(h,cmd)) q:cmd=""  do write($$$escBlue($zd(h,3))_" ") }
	}
	;for { set cmd=$Order(@gn@("cmd",cmd)) q:cmd=""  
	;do write() }
 quit $$$OK
write(date="")
	if mask'="",$zconvert(cmd,"L")'[mask quit
	set num=num+1
	set cmdline=$lg(cmd,1)
	if $D(@gn@("cmd",cmd,"nonrem")) set cmdline=$$$escRed(cmdline)
	write !,date_$$$escRed(num)_"."_$$$escViolet($lg(cmd,3))_" "_cmdline_$select($lg(cmd,4)="":"",1:" //")_$lg(cmd,4)
	set %zapm(num)=cmd
 quit
]]></Implementation>
</Method>

<Method name="CreateHistArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&list]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set gn=..#GN
	set cmd="" for {set cmd=$o(@gn@("cmd",cmd)) q:cmd=""  
	  if $D(@gn@("cmd",cmd,"date"),Hor) 
	  else  set Hor="100,1"
	  set list(Hor,cmd)=""
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="help">
<Description>
cmd 
do ##class(%ZAPM.ext.zapp).help("dark")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>mask=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set mask=$ZStrip(mask,"<>WC")
	if $e(mask,1,5)="-init" { //flags init
		do ##class(%ZAPM.ext.zapp).init(1) q $$$OK
	}
	#define escRed(%t) $Select($$$escBg=0:%t,1:$c(27)_"[1;31;"_$$$escBg_"m"_%t_$$$escClear)
	kill %zapm
	write !,$$$escViolet("Extending ZPM commands, the standard ZPM commands also work as from zpm shell.")
		,!,"Enter the command "_$$$escRed("number")_" or "_$$$escViolet("name")_" to execute."
	do ##class(%ZAPM.ext.commands).GetList(.list)
	set i=""
	for {
		set i=$Order(list(i)) q:i=""
		set ii="" 
		for { 
			set ii=$O(list(i,ii),1,val) q:ii=""
			set vall=$zconvert($lts(val),"L")
			set namecmd=$lg(val,3)
			if vall[").extcmd(%cmd)" continue
			if mask'="" {
				if vall[mask set %zapm($i(%zapm))=val do ..write(i,%zapm,%zapm(%zapm))
			}
			else {
				set %zapm($i(%zapm))=val do ..write(i,%zapm,%zapm(%zapm))
			}
		}
	}
	do ..write("","cmd or cmd context",$lb("Show help"),1)
	do ..write("","hist or hist context",$lb("Show history"),1)
	write !,$$$escBlue("A")_"-Ask before launch, "_$$$escBlue("I")_"-Launch immediately, "_$$$escBlue("N")_"-Do not run"
	;do ..write("","Q,q,^,h,H",$lb("Quit"),1)
	q $$$OK
]]></Implementation>
</Method>

<Method name="write">
<ClassMethod>1</ClassMethod>
<FormalSpec>part,num,cmd,noprompt=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	;if part="" {write !	}
	if part'=$g(%partit) { 
		set %partit=part
		w !,$$$escGreen(part)	
	}
	set prompt=$lg(cmd,2)
	;if 'noprompt set prompt=" //"_$$$escBlue($s(prompt="y":"Ask before launch",prompt="n":"Launch immediately",1:"Do not run"))
	if 'noprompt set prompt=" //"_$$$escBlue($s(prompt="a":"A",prompt="i":"I",prompt="n":"N",1:"N"))
	write !,$$$escRed(num)_"."_$$$escViolet($lg(cmd,3))_" "_$lg(cmd,1)_prompt_" "_$lg(cmd,4)
 quit $$$OK
]]></Implementation>
</Method>

<Method name="addcmd">
<Description>
do ##class(%ZAPM.ext.zapp).addcmd("new $namespace zn ""zpmshow"" do ^zpmshow","zpm","i","zshow","Show a zpm modules with extention description")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>cmd="",partion="",moderun="",namecmd="",description=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if partion="" set partion="other"
	do ##class(%ZAPM.ext.commands).GetCmd("",namecmd,.comman)
	if comman'="" write !,"command name '"_namecmd_"' already exist" q $$$OK
	set st=##class(%ZAPM.ext.commands).AddUpdate(cmd,namecmd,partion,moderun,description)
	if 'st write $System.Status.GetErrorText(st) quit st
	else  write !,"added"
	quit $$$OK
]]></Implementation>
</Method>

<Method name="UpdateLanguageExtensionsOne">
<Description>
do ##class(%ZAPM.ext.zapp).UpdateLanguageExtensions()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[RoutineName:%String,pTestOnly:%Boolean=0,*pFound:%Boolean=0,&tGenLines]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#def1arg STARTTAGQ " ;Generated by %ZAPM.ext.zapp: Start"
	#def1arg ENDTAGQ " ;Generated by %ZAPM.ext.zapp: End"
	#def1arg STARTTAG ##Expression($$$STARTTAGQ)
	#def1arg ENDTAG ##Expression($$$ENDTAGQ)
	Set tRtn = ##class(%Routine).%New(RoutineName)
	If ##class(%Routine).Exists(RoutineName) {
		Set tEnded = 1
		While 'tRtn.AtEnd {
			Set tLine = tRtn.ReadLine()
			If (tLine = $$$STARTTAGQ) {
				// Read through the ending tag.
				While ('tRtn.AtEnd) && (tRtn.ReadLine() '= $$$ENDTAGQ) {}
				
				// Generate the lines.
				Set pFound = 1
				For i=1:1:tGenLines {
					Set tRtnLines($i(tRtnLines)) = tGenLines(i)
				}
			} Else {
				Set tIsZAPM = ($ZConvert($Extract(tLine,1,4),"U") = "ZAPM(")
				If tIsZAPM {
					Set pFound = 1
					Set tEnded = 0
					Set tRtnLines($i(tRtnLines)) = $$$STARTTAGQ
				}
				If '(tIsZAPM || tEnded) {
					If ($ZStrip($Extract(tLine),"*W") '= "") {
						Set tRtnLines($i(tRtnLines)) = $$$ENDTAGQ
						Set tEnded = 1
					}
				}
				Set tRtnLines($i(tRtnLines)) = tLine
			}
		}
		If 'tEnded {
			Set tRtnLines($i(tRtnLines)) = $$$ENDTAGQ
		} ElseIf 'pFound {
			For i=1:1:tGenLines {
				Set tRtnLines($i(tRtnLines)) = tGenLines(i)
			}
		}
	} Else {
		Merge tRtnLines = tGenLines
	}
	If (pTestOnly) {
		Quit
	}
	Do tRtn.Clear()
	For i=1:1:tRtnLines {
		Do tRtn.WriteLine(tRtnLines(i))
	}
	$$$ThrowOnError(tRtn.Save())
	$$$ThrowOnError(tRtn.Compile())
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="UpdateLanguageExtensions">
<ClassMethod>1</ClassMethod>
<FormalSpec>pVerbose:%Boolean=0,pTestOnly:%Boolean=0,*pFound:%Boolean=0</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	#def1arg STARTTAGQ " ;Generated by %ZAPM.ext.zapp: Start"
	#def1arg ENDTAGQ " ;Generated by %ZAPM.ext.zapp: End"
	#def1arg STARTTAG ##Expression($$$STARTTAGQ)
	#def1arg ENDTAG ##Expression($$$ENDTAGQ)

	Set tSC = $$$OK
	Set tInitTLevel = $TLevel
	Try {
		TSTART
		// Get routine lines to generate
		Set tOffset = 0
		Set tStarted = 0
		For {
			Set tLineName = "zUpdateLanguageExtensions"_"+"_$i(tOffset)_"^"_$ZName
			Set tExtLine = $Text(@(tLineName))
			If (tExtLine=$$$STARTTAGQ) {
				Set tStarted = 1
			}
			If (tStarted) {
				Set tGenLines($i(tGenLines)) = tExtLine
			}
			Quit:(tExtLine=$$$ENDTAGQ)
			Quit:(tExtLine="")
		}

		If '$Data(tGenLines) {
			$$$ThrowStatus($$$ERROR($$$GeneralError,"Could not find %ZLANGC00 routine contents in "_$classname()))
		}
		Do ..UpdateLanguageExtensionsOne("%ZLANGC00.MAC", pTestOnly,.pFound,.tGenLines)
		Quit:pTestOnly
		Set i="" 
		For { set i=$Order(tGenLines(i),1,tStr) Quit:i=""
			If tStr[" Do ##class" Set tGenLines(i)=$Replace($Replace(tStr," Quit","")," Do "," Quit ") Quit
		}
		Do ..UpdateLanguageExtensionsOne("%ZLANGF00.MAC", pTestOnly,.pFound,.tGenLines)
		TCOMMIT
	} Catch e {
		Set tSC = e.AsStatus()
	}
	While ($TLevel > tInitTLevel) {
		TROLLBACK 1
	}
	Quit tSC
#; These are the actual contents of %ZLANGC00 (to be added/updated)
$$$STARTTAG
ZAPM(pArgs...) Do ##class(%ZAPM.ext.zapp).prompt(pArgs...) Quit
$$$ENDTAG
#; Need an extra line down here to avoid the end bracket being on the same line as $$$ENDTAG - a comment is just fine.
]]></Implementation>
</Method>
</Class>


<Class name="%ZAPM.ext.zpm">
<Description>
installation string ZPM, ZAPM, Registry
set $namespace="%SYS", name="DefaultSSL" do:'##class(Security.SSLConfigs).Exists(name) ##class(Security.SSLConfigs).Create(name) set url="https://pm.community.intersystems.com/packages/zpm/latest/installer" Do ##class(%Net.URLParser).Parse(url,.comp) set ht = ##class(%Net.HttpRequest).%New(), ht.Server = comp("host"), ht.Port = 443, ht.Https=1, ht.SSLConfiguration=name, st=ht.Get(comp("path")) quit:'st $System.Status.GetErrorText(st) set xml=##class(%File).TempFilename("xml"), tFile = ##class(%Stream.FileBinary).%New(), tFile.Filename = xml do tFile.CopyFromAndSave(ht.HttpResponse.Data) do ht.%Close(), $system.OBJ.Load(xml,"ck") do ##class(%File).Delete(xml) zpm "install zapm" zapm "newdb zpm-registry" zapm "zna"
research and development ZPM</Description>
<Abstract>1</Abstract>
<IncludeCode>%ZAPM.ext.Common</IncludeCode>
<TimeCreated>65692,84099.653344</TimeCreated>

<Parameter name="VERSION">
<Default>1.0.15</Default>
</Parameter>

<Parameter name="GN">
<Description>
Storage of work history</Description>
<Default>^%ZAPM.ZpmLoad</Default>
</Parameter>

<Method name="extcmd">
<Description>
extention zpm commans
do ##class(%ZAPM.ext.zpm).extcmd("load https://github.com/Vassil2010/iris-sms")
zapp "newdb spool-demo"</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>cmd=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if $lf($lb("find","search"),$p(cmd," ")) quit ##class(%ZAPM.ext.zpm).find($p(cmd," ",2,*)_" ")
	if $p(cmd," ")="help" quit ##class(%ZAPM.ext.zpm).help($p(cmd," ",2,*))
	if $p(cmd," ")="newdb" quit ##class(%ZAPM.ext.zpm).CreateDBNSAndLoad($p(cmd," ",2,*))
	if $p(cmd," ")="load" quit ##class(%ZAPM.ext.zpm).LoadFromRepo($p(cmd," ",2,*))
	if $p(cmd," ")="ver" zpm "ver" write !,$$$escGreen("zapm")_" "_..#VERSION,!
	if $p(cmd," ")="info" quit ##class(%ZAPM.ext.zpm).info($p(cmd," ",2,*)_" ")
	if $p(cmd," ")="repo" set st=##class(%ZPM.PackageManager).Shell(cmd) do:cmd'="repo -list"&&(cmd["repo -r -n ") ##class(%ZPM.PackageManager).Shell("repo -list") quit st
	if $p(cmd," ")="upg" quit ##class(%ZAPM.ext.zpm).Upgrade($p(cmd," ",2,*))
	if $e(cmd,1,2)="ed" quit ##class(%ZAPM.ext.zpm).editor(cmd) 
	if $p(cmd," ")="dbcreate" {
		if ($p(cmd," ",2,*))[" -p " set path=$p($p(cmd," -p ",2)," ")
		 quit ##class(%ZAPM.ext.database).CreateDBNS($p(cmd," ",2),,$GET(path))
	}
	if $p(cmd," ")="dbdelete" quit ##class(%ZAPM.ext.database).DeleteDBNS($p(cmd," ",2,*))
	
	;if $p(cmd," ")="rolecreate" quit ##class(%ZAPM.ext.database).CreateRole($p(cmd," ",2,*))
	;if $p(cmd," ")="roledelete" quit ##class(%ZAPM.ext.database).DeleteRole($p(cmd," ",2,*))
]]></Implementation>
</Method>

<Method name="editor">
<ClassMethod>1</ClassMethod>
<FormalSpec>cmd</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	;if '$$EXIST^%R("%ZAPM.ed.BSC") write !,"Extension zapm-editor not installed. To install, run: zapm ""install zapm-editor"" " quit $$$OK
	if $p(cmd," ")="edt" do ^%ZAPM.ed.BSC,rest quit $$$OK
	if $p(cmd," ")="edn" do nszpm^%ZAPM.ed.a,rest quit $$$OK
	if $p(cmd," ")="edg" do glo^%ZAPM.ed.a($p(cmd," ",2)),rest quit $$$OK
	if $p(cmd," ")="edr" do rou^%ZAPM.ed.a($p(cmd," ",2)),rest quit $$$OK
	if $p(cmd," ")="edf" ;TODO do ^%ZAPM.bs.BSX($p(cmd," ",2)),rest quit $$$OK ;file system
	if $p(cmd," ")="eds" ;TODO do ^%ZAPM.bs.BSX($p(cmd," ",2)),rest quit $$$OK ;sql queries
	quit $$$OK
rest open 0:(:) write $$$escClear
 quit
]]></Implementation>
</Method>

<Method name="info">
<ClassMethod>1</ClassMethod>
<FormalSpec>extcmd</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set tDesc=1 ;+$g(pCommandInfo("data","Desc"))
	quit:'..GetListModule(,.tModMap,'tDesc)
		Set tMod = ""
		For { Set tMod = $Order(tModMap(tMod),1,tVersion)
			Quit:(tMod="")
			Write !,$$$escGreen(tMod)," ",tVersion_" "
			If tDesc,$Data(tModMap(tMod,"L"),Lock) {
				Set maxlenname=$L(tMod_" "_tVersion_" ")
				Do ..DrawColumn($$$escYellow("Description: ")_$ListGet(Lock,2))
				Set au=3 
				For a="Author_CopyrightDate", "Author_License", "Author_Notes", "Author_Organization", "Author_Person" { 
					Set au=au+1
					set audata=$ListGet(Lock,au)
					Write:audata'="" !
					,?(maxlenname)
					,..DrawColumn($$$escViolet(a_": ")_audata)
				}
				set dirroot=$ListGet(Lock,3)
				Write !
					,?(maxlenname)
					,..DrawColumn($$$escViolet("Root: ")_dirroot)
				if $Data(tModMap(tMod,"R"),Rem) {
					write !,$ListGet(Rem,3)
				}
				if (extcmd)["-r " kill out do ..GetFileLines(dirroot_"README.md",.out),..DrawArray(.out)
				if (extcmd)["-m " kill out do ..GetFileLines(dirroot_"module.xml",.out),..DrawArray(.out)
				if (extcmd)["-f " kill out do ..GetAllDir(dirroot,,.out),..DrawArray(.out,dirroot)
			}
		}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawArray">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&Array:%String,ListDir=""]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set i="" for  {set i=$o(Array(i),1,str) q:i=""  
		if ListDir="" write !,$$$escRed(str) continue
		if $lg(str,2)="F" write !,$$$escRed($p($lg(str,1),ListDir,2))
	}
]]></Implementation>
</Method>

<Method name="GetAllDir">
<Description>
Get all files in a directory and subdirectories</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[dir,ext="",&out]]></FormalSpec>
<Implementation><![CDATA[
	set dir = ##class(%File).NormalizeDirectory(dir)
	set rs = ##class(%ResultSet).%New("%File:FileSet")
	s sc=rs.Execute(dir, ext)
	while (rs.Next()) {
		set out($i(out)) = $lb(rs.Get("Name"),rs.Get("Type"),rs.Get("Size"),rs.Get("ItemName"),rs.Get("DateCreated"),rs.Get("DateModified"))
		i rs.Get("Type")="D" d ..GetAllDir($lg(out(out),1),ext,.out)
	}
	q $$$OK
]]></Implementation>
</Method>

<Method name="GetFileLines">
<Description>
from %ZPM.PackageManager.Developer.Utils</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>pFileName:%String,*pOutput</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set tSC = $$$OK
	set curio=$i
	Try {
		Kill pOutput
		Close pFileName Open pFileName:("RS"):5
		If '$T Set tSC = $$$ERROR($$$CacheError, "Failed to open file '"_pFileName_"'") Quit
		Set TooMuch = 0
		Use pFileName
		For {
			// Keep reading through end of file; save only first 32,000 characters
			Set tLine = "" Read tLine:1
			If '$T && (tLine=$C(-1)) Quit  // Exit by timeout
			If $Length(tLine)<32000 {
				Set pOutput($i(pOutput)) = tLine
			} Else {
				Set pOutput($i(pOutput)) = $E(tLine,1,32000)_" (more...)"
			}
			If ($ZEOF=-1) Quit  // Exit by EOF
		}
		Close pFileName
	} Catch e {
		Set tSC = e.AsStatus()
		Close pFileName
	}
	use curio
	Quit tSC
]]></Implementation>
</Method>

<Method name="find">
<ClassMethod>1</ClassMethod>
<FormalSpec>extcmd</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	if (extcmd)[" -r " set ViewRepo=1
	if (extcmd)[" -d " set ViewFromModule=1
	if (extcmd)[" -u " set ViewUrl=$p($p(extcmd," -u ",2)," ")
	do ##class(%ZAPM.ext.zpm).Description($p(extcmd," "),$GET(ViewUrl),$GET(ViewRepo),$GET(ViewFromModule))
	quit $$$OK
]]></Implementation>
</Method>

<Method name="help">
<ClassMethod>1</ClassMethod>
<FormalSpec>cmd=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	OPEN 2:$j USE 2
	if '$lf(..cmdzpmext(),cmd) {
		do ##class(%ZPM.PackageManager).Shell("help "_cmd)
		do ##class(%ZAPM.ext.zpm).exthelp(cmd)
	}
	else { 
		do ##class(%ZAPM.ext.zpm).exthelp(cmd)
		}
 	CLOSE 2
 	set i=""
 		,help=""
 		,cmds=..cmdzpm()_..cmdzpmext()
 	for { set i=$o(^SPOOL($j,i),1,s) q:i=""
 		set s=" "_s
 		if $o(^SPOOL($j,i)) {
	 		for cm=1:1:$ll(cmds) if s[(" "_$lg(cmds,cm)_" ") set s=$replace(s," "_$lg(cmds,cm)_" "," "_$$$escViolet($lg(cmds,cm))_" ")
 			set help=help_s
 		}
 	}
 	KILL ^SPOOL($j)
	write !,help
	quit $$$OK
]]></Implementation>
</Method>

<Method name="exthelp">
<ClassMethod>1</ClassMethod>
<FormalSpec>cmd=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
 if cmd="" {
	write !!,"Available commands extention:"
	write !,"-----------------------------"
 }
 if cmd=""||(cmd="newdb") {
	write !!,"newdb <module>"
 	write !," Create a new database and an Namespace with a name derived from the name of the module and Install the module into it,"
 }
 if cmd=""||(cmd="dbcreate") {
	write !!,"dbcreate namespace <path>"
 	write !," Create a new database and an Namespace,"
 	write !," dbcreate testdb2 -p d:/!/database/durable"
 }
 if cmd=""||(cmd="dbdelete") {
	write !!,"dbdelete namespace"
 	write !," Delete database and an Namespace,"
 }
 if cmd=""||(cmd="info") {
	write !!,"info "
 	write !," Show more complete information about modules in the current namespace."
	write !,"info -m module"
 	write !," Show file module.xml."
	write !,"info -f module"
 	write !," List file in repository."
	write !,"info -r module"
 	write !," Show file readme.md."
 }
 if cmd=""||(cmd="upg") {
	write !!,"upg "
 	write !," Upgrade the versions of modules installed in the current namespace."
 }
 if cmd=""||(cmd="load") {
	write !!,"load http://git-repo/developer-name/repo-name"
 	write !," Load the module directly from the repository into the current Namespace. The 'git clone' command is applied. The git program must be installed."
 }
 if cmd=""||(cmd="find")||(cmd="search") {
	write !!,"find app* -d  load description from modules, and the description is always displayed"
 	write !!,"find app* -u /rcemper  show modules only including context from repository"
 }

 if cmd=""||(cmd="cmd") {
	write !!,"cmd "
 	write !," Alias: ?"
 	write !," Show all commands."
 	write !!,"cmd <context>"
 	write !," Show all commands including context."
 	write !!,"cmd -init"
 	write !," Reload all commands. Run do ##class(%ZAPM.ext.zapp).init()"
 }
 if cmd=""||(cmd="hist") {
	write !!,"hist "
	write !," Alias: ??"
 	write !," Show all history."
 	write !!,"hist <context>"
 	write !," Show all history including context."
 	write !!,"hist - <context>"
 	write !," Show all history including context. Sorting by date"
 	write !!,"hist + <context>"
 	write !," Show all history including context. Reverse sorting by date"
 	write !!,"hist -del Number_day"
 	write !," Delete all history older than the number of days."
 	write !!,"hist -add Number_hist"
 	write !," Added history in list for non-removable."
 	write !!,"hist -add Number_hist [name_cmd] [a/i/n] description"
 	write !," Added history in list commans."
 }
 if $$EXIST^%R("%ZAPM.ed.a") {
	if cmd=""||($e(cmd,1,2)="ed") {
	write !!,"edn - Navigator for namespace and zpm modules"
	write !,"edg - Globals editor"
	write !,"zapm ""edg ^test"" - Globals editor"
	write !,"zapm ""edg lockarray"" - Local array editor"
	write !,"edr - Routine editor"
	;write !,"edf - Filesystem navigator"
	}
}
 write !
	quit $$$OK
]]></Implementation>
</Method>

<Method name="cmdzpm">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit $lb("ver","quit","help","namespace","orphans","list-dependents","list-installed","reload","compile","test","package","verify","publish","load","zn","help","install","uninstall","manage","list","find","search","version","repo","config","generate")
]]></Implementation>
</Method>

<Method name="cmdzpmext">
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[	quit $lb("newdb","cmd","hist","dbcreate","dbdelete","upg","info","edt","edg","edf","edr","edn","edf","eds")
]]></Implementation>
</Method>

<Method name="SetColorScheme">
<Description>
do ##class(%ZAPM.ext.zpm).SetColorScheme("dark")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>scheme={$s($zversion(1)=3:"dark",1:"white")}</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	write !,1,scheme,1
	Quit ##class(%ZPM.PackageManager).Shell("config set ColorScheme "_scheme)
]]></Implementation>
</Method>

<Method name="Upgrade">
<Description>
Upgrade all installed modules
write ##class(%ZAPM.ext.zpm).Upgrade()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ns=$namespace</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	do ##class(%ZAPM.ext.zpm).GetListModule(ns,.List,0)
	set name=""
	for { set name=$Order(List(name)) quit:name=""
		if $LISTGET(List(name,"L"),1)'=$LISTGET($GET(List(name,"R")),1) {
			set Diff(name)="" 
			write !," "_$$$escGreen(name)_" Local: "_$LISTGET(List(name,"L"),1)_" Registr: "_$LISTGET($GET(List(name,"R")),1)
		}
	}
	if '$DATA(Diff) {
		write !,"The versions of the modules are the same. Updating anyway? [Y/N]<N>"
		read upd
		if $zconvert(upd,"L")["y" do ..UpgradeList(.List)
	}
	else {
		write !,"Updating different modules or all? [Y/A/N]<N>"
		read upd 
		set upd=$zconvert(upd,"L")
		if upd["y" {do ..UpgradeList(.Diff)}
		elseif upd["a" {do ..UpgradeList(.List)}
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="UpgradeList">
<Description>
write ##class(%ZAPM.ext.zpm).UpgradeList(.list)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>List</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set name=""
	for { set name=$Order(List(name)) quit:name=""
		zpm "install "_name
	}
]]></Implementation>
</Method>

<Method name="GetListModule">
<Description>
do ##class(%ZAPM.ext.zpm).GetListModule(,.List)
Get module list in currently namespace</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[ns=$namespace,&Mod,OnlyName=1]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	new $namespace
	set $namespace=ns
	Set tRes = ##class(%SQL.Statement).%ExecDirect(,
		"select * from %ZPM_PackageManager_Developer.""MODULE""")
	If (tRes.%SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
	}
	set in=""
	While tRes.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		Set name=tRes.%Get("Name")
		set in=in_"'"_name_"',"
		set list=$lb(tRes.%Get("VersionString"),tRes.%Get("Description"),tRes.%Get("Root"))
		For a="Author_CopyrightDate", "Author_License", "Author_Notes", "Author_Organization", "Author_Person" {
			Set list=list_$lb(tRes.%Get(a))
		}
		Set Mod(name) = tRes.%Get("VersionString")
		Set:'OnlyName Mod(name,"L") = list
		
	}
	$$$ThrowOnError(tSC)
	quit:in=""||(OnlyName) $$$OK
	set in=$Extract(in,1,*-1)

	Set tQuery = "select Name, Version, Repo, Description from %ZPM_PackageManager_Developer.Utils_GetModuleList('registry') WHERE name in ("_in_")"
	Set tRes = ##class(%SQL.Statement).%ExecDirect(,tQuery)
	
	If (tRes.%SQLCODE < 0) {
		Throw ##class(%Exception.SQL).CreateFromSQLCODE(tRes.%SQLCODE,tRes.%Message)
	}
	While tRes.%Next(.tSC) {
		$$$ThrowOnError(tSC)
		Set Mod(tRes.%Get("Name"),"R")=$Listbuild(tRes.%Get("Version"),tRes.%Get("Description"),tRes.%Get("Repo"))
	}
	quit $$$OK
]]></Implementation>
</Method>

<Method name="LoadFromRepo">
<Description>
write ##class(%ZAPM.ext.zpm).LoadFromRepo("https://github.com/Vassil2010/iris-sms")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>path=""</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set sls=$$$slash
	set st=$$$OK
	if $e(path,1,4)="http" {
		set dirrepo=$p($p(path,"/",*),".git")
		set dirrnd=$tr($zts,".,")
		Set TempDir = ##class(%File).GetDirectory(##class(%File).GetDirectory($zu(86))_"mgr"_sls_"Temp"_sls_dirrnd_sls)
		set st=##class(%File).CreateDirectoryChain(TempDir)
		if 'st  write !,$System.Status.GetErrorText(st) q st
		;write !,"Create tempory directory "_TempDir
		//first try
		set UrlArchive = ..GetUrlRepoArhive(path)
		if UrlArchive'="" {
			Do ##class(%Net.URLParser).Parse(UrlArchive,.tComponents)
			Set tClient = ##class(%ZPM.PackageManager.Client.REST.PackageManagerClient).%New()
			set tRequest = tClient.GetHttpRequest(UrlArchive)
			Set tRequest.Timeout = 300
    		Set tSC = tRequest.Get(tComponents("path"))
    		If $$$ISOK(tSC), tRequest.HttpResponse.StatusCode=200 {
      			Set tFileBinStream = ##class(%Stream.FileBinary).%New()
      			Set tFileBinStream.Filename = TempDir_"tmp.zip"
      			do tFileBinStream.CopyFromAndSave(tRequest.HttpResponse.Data)      
			}
		  	If $GET(tFileBinStream)'="" {
				if $zversion(1)=3 { //for Linux
					set cmd="cd "_TempDir_" && unzip -q tmp.zip"
				}
				else { //for Windows
					set cmd="cd "_TempDir_" && powershell Expand-Archive -LiteralPath "_TempDir_"tmp.zip -DestinationPath "_TempDir
				}
				write !,cmd,!
				$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Utils).RunCommandViaZF(cmd,.tLog,.tErr))
				hang 2
			}
		}
		if $$$FileSize(TempDir_dirrepo_"-master"_sls_"module.xml")>0 {
			set st=##class(%ZPM.PackageManager).Shell("load "_TempDir_sls_dirrepo_"-master")
			do ##class(%File).RemoveDirectoryTree(TempDir)
			if 'st write !,$System.Status.GetErrorText(st)
			Quit st
		}
		//second try
		set cmd="cd "_TempDir_" && git clone "_path
		write !,cmd,!
		$$$ThrowOnError(##class(%ZPM.PackageManager.Developer.Utils).RunCommandViaZF(cmd,.tLog,.tErr))
		hang 2
		if $$$FileSize(TempDir_dirrepo_sls_"module.xml")>0 {
			set st=##class(%ZPM.PackageManager).Shell("load "_TempDir_sls_dirrepo)
			do ##class(%File).RemoveDirectoryTree(TempDir)
			if 'st write !,$System.Status.GetErrorText(st)
			Quit st
		}
	}
	else {
		Quit ##class(%ZPM.PackageManager).Shell("load "_path)
	}
	q $$$OK
]]></Implementation>
</Method>

<Method name="GetUrlRepoArhive">
<Description>
https://github.com/SergeyMi37/zapm-addcmd.git
https://codeload.github.com/SergeyMi37/zapm/zip/master
write ##class(%ZAPM.ext.zpm).GetUrlRepoArhive("https://github.com/SergeyMi37/zapm-addcmd.git")
https://gitlab.com/sergeymi/test.git
https://gitlab.com/sergeymi/test/-/archive/master/test-master.zip
write ##class(%ZAPM.ext.zpm).GetUrlRepoArhive("https://gitlab.com/sergeymi/test.git")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>tLocation</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	Do ##class(%Net.URLParser).Parse(tLocation,.tComponents)
	set reponame=$piece($piece(tComponents("path"),"/",3),".")
	If tComponents("host")="gitlab.com" {
		set ref="https://gitlab.com/"_$piece(tComponents("path"),"/",2)_"/"_reponame_"/-/archive/master/"_reponame_"-master.zip"
	}
	If tComponents("host")="github.com" {
		set ref="https://codeload.github.com/"_$piece(tComponents("path"),"/",2)_"/"_reponame_"/zip/master"
	}
	quit $get(ref)
]]></Implementation>
</Method>

<Method name="LoadRegistrys">
<Description>
zpm-utility 
repo -r -n registry -url http://127.0.0.1:52773/registry/ -user "superuser" -pass "pass"
do ##class(%ZAPM.ext.zpm).LoadRegistrys("c*",1)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>modulename="",all=0,skipZPM=1</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set currns=$namespace
	set gn=..#GN
	set sql="select Name, Version, Repo, Description from %ZPM_PackageManager_Developer.Utils_GetModuleList('registry') "_$s(modulename="":"",modulename["*":"where Name like '"_$tr(modulename,"*","%")_"'",1:"where Name=?")
		,rs=##class(%ResultSet).%New()
		,sc=rs.Prepare(sql)
	set:sc sc=rs.Execute($zconvert(modulename,"L"))
	write !,sql
	if sc {
		for i=1:1 {
			quit:'rs.%Next()  
			set name=rs.Get("Name")
			set Version=rs.Get("Version")
			set Repo=rs.Get("Repo")
			set ns=$zconvert($tr(name,"-."),"U")
			if skipZPM, name["apptools"||($e(name,1,3)="zpm")||(name["appmsw")||($e(name,1,4)="zapm") w !,"Skip "_$$$escGreen(name) continue
			if $d(@gn@(name)) { ;already load
				if $lg($g(@gn@(name,"generate")),2)'=""||($lg($g(@gn@(name,"install")),1)'="") {
					write !,ns_" Unload Removed DBNS ? Y\N " Read R   quit:"q"[R
					if $g(R)="y" {
						do ##class(%ZAPM.ext.zpm).UnloadAndDeleteDBNS(name,,,gn)
						kill @gn@(name)
					}
					continue
				}
				write !,"Already loaded - Skip "_$$$escGreen(name)
			} elseif 1 {
				set sta=##class(%ZPM.PackageManager).Shell("find -r -d "_name) write !
				if 'sta s err=$System.Status.GetErrorText(sta) w !,err w !,"Skip" continue
				if 'all w !,ns_" Load into a new database ? Y\N " Read R   quit:"q"[R
				if $g(R)="y"||(all=1) {
					do ##class(%ZAPM.ext.zpm).CreateDBNSAndLoad(name,,,,gn,.error)
					if $g(error)["<INTERRUPT>" quit
				}
			}
		}
	}
	write !,"Log in global ",!,gn
]]></Implementation>
</Method>

<Method name="UnloadAndDeleteDBNS">
<Description>
d ##class(%ZAPM.ext.zpm).UnloadAndDeleteDBNS("sync-dstime")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name,Version="",Repo="",gn=..#GN</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	set currns=$namespace
	new $namespace
	s ns=$zconvert($tr(name,"-."),"U")
	set $Namespace=ns
	set sta=##class(%ZPM.PackageManager).Shell("uninstall "_name)
	if 'sta w !,$system.Status.GetErrorText(sta)
	else  k @gn@(name)
	set $namespace=currns
	s st=##class(%ZAPM.ext.database).DeleteDBNS(ns)
	i 'st w $system.Status.GetErrorText(st)
]]></Implementation>
</Method>

<Method name="CreateDBNSAndLoad">
<Description>
d ##class(%ZAPM.ext.zpm).CreateDBNSAndLoad("isc-tar")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>name,ns="",Version="",Repo="",gn="",err</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	new $namespace
	k err w !
	if ns="" s ns=$zconvert($tr(name,"-."),"U")
	s st=##class(%ZAPM.ext.database).CreateDBNS(ns)
	i 'st s err=$System.Status.GetErrorText(st) w !,err
	s:gn'="" @gn@(name,"generate")=$lb(ns,$g(err),st)
	if st {
		zn ns
		;s sta=$zpm("install "_name_" -v")
		kill err
		write !,"zpm ""install "_name_""""
		set sta=##class(%ZPM.PackageManager).Shell("install "_name)
		if 'sta s err=$System.Status.GetErrorText(sta) w !,err 
		set:gn'="" @gn@(name,"install")=$lb($g(err),sta,Version,Repo)
		if $g(err)["<INTERRUPT>" quit sta
	}
	q $$$OK
]]></Implementation>
</Method>

<Method name="CompNS">
<Description>
Recompilation to IRIS namespace
d ##class(%ZAPM.ext.zpm).CompNS("AAA")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>ns</FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	zn ns
	d ##class(%EnsembleMgr).EnableNamespace(ns,1)
	w !,"Compilation started, please wait..."
	k err d $system.OBJ.CompileAll("cfk-u-d",.err) zw err
	q $$$OK
]]></Implementation>
</Method>

<Method name="CollectPackage">
<ClassMethod>1</ClassMethod>
<FormalSpec>pPath:%String,*pList,pRoot:%String</FormalSpec>
<Implementation><![CDATA[
  set rs = ##class(%File).FileSetFunc(pPath)
  WHILE rs.%Next() {
    If rs.Type="D" {
      do ..CollectPackage(rs.Name, .pList, pRoot)
    } ELSE {
      #; Set $LISTBUILD(url) = $SYSTEM.CSP.FilenameToUrls(rs.Name) 
      Set pList($INCREMENT(pList)) = $LISTBUILD(rs.Name, $EXTRACT(rs.Name, $LENGTH(pRoot) + 1, *))
    }
  }
]]></Implementation>
</Method>

<Method name="CompactPackage">
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[&pList,classname=$CLASSNAME()]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
  set file = ""
  for i=1:1:$Get(pList) {
    Set $LISTBUILD(file, name) = pList(i)
    
    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = file

    Set gzip = ##class(%Stream.FileBinaryGzip).%New()
    Set gzip.Filename = tmpFile
    do gzip.CopyFromAndSave(stream)
    
    Set gzip = ##class(%Stream.FileBinary).%New()
    Set gzip.Filename = tmpFile

    Set xdata = ##class(%Dictionary.XDataDefinition).%New()
    Set xdata.Name = "Data"_i
    Set xdata.Description = name
    Do xdata.parentSetObjectId(classname)
    set chunkSize = 22800
    while 'gzip.AtEnd {
      set data = gzip.Read(chunkSize)
      set base64 = $SYSTEM.Encryption.Base64Encode(data)
      do xdata.Data.WriteLine(base64)
      set data1 = $SYSTEM.Encryption.Base64Decode(base64)
    }
    do xdata.%Save()
    set hash = $SYSTEM.Encryption.SHA1HashStream(gzip)
  
    do ##class(%File).Delete(tmpFile)
  }
  QUIT $$$OK
  
  
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="ExtractPackage">
<ClassMethod>1</ClassMethod>
<FormalSpec>*pFolder:%String,classname=$CLASSNAME()</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
  Set pFolder = ##class(%File).NormalizeDirectory($$$FileTempDir)

  For i=1:1:..#FILESCOUNT {
    Set xdata = ##class(%Dictionary.XDataDefinition).%OpenId(classname_"||Data"_i)
    Set name = xdata.Description
    Set fileName = pFolder_name

    Set tParentFolder = ##class(%File).ParentDirectoryName(fileName)    
    if '##class(%File).DirectoryExists(tParentFolder) {
      Do ##class(%File).CreateDirectoryChain(tParentFolder)
    }

    set tmpFile = ##class(%File).TempFilename("gz")

    set stream = ##class(%Stream.FileBinary).%New()
    set stream.Filename = tmpFile
    set prev = ""
    set chunkSize = 30400
    do {
      set data = prev
      if 'xdata.Data.AtEnd {
        set data = data _ xdata.Data.Read()
      }
      set data = $ZSTRIP(data, "*C")
      set prev = $EXTRACT(data, chunkSize + 1, *)
      set data = $EXTRACT(data, 1, chunkSize)
      set chunk = $SYSTEM.Encryption.Base64Decode(data)
      do stream.Write(chunk)
    } while (prev'="")||('xdata.Data.AtEnd)
    do stream.%Save()

    set gzip = ##class(%Stream.FileBinaryGzip).%New()
    set gzip.Filename = tmpFile

    set fs = ##class(%Stream.FileCharacter).%New()
    set fs.Filename = fileName
    do fs.CopyFromAndSave(gzip)

    do ##class(%File).Delete(tmpFile)
  }
  Quit $$$OK
]]></Implementation>
</Method>

<Method name="add2xdata">
<Description>
Add XDATA to another class
 d ##class(%ZAPM.ext.zpm).add2xdata("/backup/iris/distr/apptools-task/","Test.test")</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>dir="d:\_proj\_zpm\appt-core\src\cls\",classname</FormalSpec>
<Implementation><![CDATA[
	;w $classname() q
	Do ..CollectPackage(dir, .tList, dir)
	zw tList
    ;Do ##class(%ZPM.Installer).CompactPackage(.tList,"App.MSW.type")
    Do ..CompactPackage(.tList,classname)
]]></Implementation>
</Method>

<Method name="EscColor">
<Description>
Output color escape sequence
do ##class(%ZAPM.ext.zpm).EscColor()</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>mode=""</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	if mode="" { //write all colors
		write ..EscColor(0)
		//brightness
		for b=1,2 {
			for f=30:1:37 {  //font
				for i=40:1:47 {  //background
					s code=b_";"_f_";"_i
					s txt=" write $$$escSeq("""_code_""",""any text"")"
					w !,$$$escSeq(code,txt)
				}
			}
		}
	
	} elseif mode=0 { //cleaning
		q $c(27)_"[0m"
	} else {
		q $c(27)_"["_mode_"m"
	}
]]></Implementation>
</Method>

<Method name="ZPMColorScheme">
<Description>
write ##class(%ZAPM.ext.zpm).ZPMColorScheme()</Description>
<ClassMethod>1</ClassMethod>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
	try {
		set scheme=##class(%ZPM.PackageManager.Client.Settings).GetValue("ColorScheme")
	} 
	catch e {
		set scheme=0
	}
	quit scheme
]]></Implementation>
</Method>

<Method name="Description">
<Description>
Show description 
do ##class(%ZAPM.ext.zpm).Description("z*","/rcep",1)</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>tModuleName,UrlInc="",RepoView="0",ViewFromModule=0</FormalSpec>
<Implementation><![CDATA[
	#define gn "^||tmpDesc"
	Kill @$$$gn
	Set tRegistry = ""
	If (tModuleName["/") {
		set $lb(tRegistry, tModuleName) = $lfs(tModuleName, "/")
	}
	set where=""
		,maxlenname=0
		,Module=""
	If tModuleName["*" {
		Set where="where name like ?"
		Set Module=$Replace(tModuleName,"*","%")
	} Elseif tModuleName'="" { 
		Set Module=tModuleName
		Set where="where name = ?"
	}
	If UrlInc'="" set RepoView=1 Write !,"Search by owner repository "_$$$escRed(UrlInc) Set where=where_" order by Repo "
	If where="" Write !,"Search the entire repository"
	Else  Write !,"Search the repository context "_Module
	//Load the list info registry modules
	Set sql="select Name, Version, Repo, Description from %ZPM_PackageManager_Developer.Utils_GetModuleList('registry') "_where
		,rs=##class(%ResultSet).%New()
		,sc=rs.Prepare(sql)
	Set:sc sc=rs.Execute(Module)
	set maxlenname=20
	If sc {
		For i=1:1 {
			Quit:'rs.%Next()  
			Set name=rs.Get("Name")
			set (Description,desc)=rs.Get("Description")
			Set (repo,url)=rs.Get("Repo")
			If $Zconvert(url,"L")'[$Zconvert($Get(UrlInc),"L") Continue
			if desc="",ViewFromModule	{
				Do ..GetDescFromRepo(url,.desc,.repo,.modxml)
				if desc="" { set desc="not yet"}
				else { set desc="from module.xml: "_desc}
			}
			Write !,$$$escGreen(name)
				,?(maxlenname+1),rs.Get("Version")
				,?(maxlenname+8),$$$escYellow("Desc: ")_desc
			if $Get(UrlInc)'="",repo'="" set repo=$replace(repo,UrlInc,$$$escRed(UrlInc))
			if RepoView write:repo'="" !?3,repo
		 }
	}
	Else { 
		Write !,"Not found "_tModuleName_" in current registry"
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="DrawColumn">
<Description>
draw description, code from zpmshow.mac</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec>desc</FormalSpec>
<ReturnType>%String</ReturnType>
<Implementation><![CDATA[
 Set dx=$x
	For d=1:1:$Length(desc," ") {
 		Set wd=$Piece(desc," ",d) 
		If $x+$l(wd)>80 Write !,?dx
		Write wd," " 
	}
 Quit ""
]]></Implementation>
</Method>

<Method name="GetDescFromRepo">
<Description>
TODO GitLab repo</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[url:%String,&desc,&repo,&modxml]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	Set desc=""
	Set url="https://raw.githubusercontent.com"_$Piece(url,"/github.com",2)
	If url="" {
		Set repo="not repository"
	}
	Else {
		Set:$Extract(url,*)'="/" url=url_"/"
		Set url=url_"master/module.xml"
		If ..GetDataURL(url,.modxml) {
			Set desc=$Piece($Piece($Get(modxml),"Description>",2),"</")
			If 0,desc="",..GetDataURL($replace(url,"module.xml","README.md"),.readme) {
				Set d=$Translate($Extract(readme,1,300),$Char(13,10),"  ")
				If d["](" {
					For  { Quit:d'["]("
						Set d=$Translate($Piece(d,"](",1),"[()","   ")_$Piece($Piece(d,"](",2,*),")",$Select($Piece(d,"](",2,*)[")":2,1:1),*)
						
					}
				}
				Set desc="from readme: "_d_"..."
			}
		}
	}
	Quit $$$OK
]]></Implementation>
</Method>

<Method name="GetDataURL">
<Description>
write $System.Status.GetErrorText(##class(%ZPM.PackageManager).GetDataURL("https://raw.githubusercontent.com/intersystems-community/zpm/master/module.xml",.o)) w o</Description>
<ClassMethod>1</ClassMethod>
<FormalSpec><![CDATA[url:%String,&data]]></FormalSpec>
<ReturnType>%Status</ReturnType>
<Implementation><![CDATA[
	New $Namespace
	Set data=""
 	#dim req As %Net.HttpRequest
	Set req=##class(%Net.HttpRequest).%New()
	Set server=$p(url,"/",3)

	If server[":" {
		Set port=$p(server,":",2)
		Set server=$p(server,":")
	}
	If $zconvert(url,"L")["https:" {
	 	Set SSLConfig = "ZPM"
	 	Zn "%SYS"
	 	Do:'##class(Security.SSLConfigs).Exists(SSLConfig) ##class(Security.SSLConfigs).Create(SSLConfig)
	 	Set req.Https=1
		Set req.SSLConfiguration=SSLConfig
		Set:$g(port)="" port=443
	}
	Set:$Get(port)="" port=80
	Set req.Server=server
	Set req.Port=port
	Set location=$Piece(url,"/",4,*)

	Set req.Location =location

	Set st = req.Get()
	Return:$$$ISERR(st) st
	Return:(req.HttpResponse.StatusCode = 404) $$$ERROR($$$GeneralError,"Repository doesn't exist OR you don't have access")
	Return:((req.HttpResponse.StatusCode = 403) && (req.HttpResponse.GetHeader("X-RATELIMIT-REMAINING")=0)) $$$ERROR($$$GeneralError,"API rate limit exceeded. Try logging in.")
 	Return:(req.HttpResponse.StatusCode '= 200) $$$ERROR($$$GeneralError,"Received " _ req.HttpResponse.StatusCode _ " status, expected 200")

	Set data=req.HttpResponse.Data.Read()

 	Return $$$OK
]]></Implementation>
</Method>
</Class>
</Export>
